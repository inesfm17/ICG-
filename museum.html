<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Museu Virtual de Moda</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 1px 1px 1px black;
        }
        #zoomOutBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            display: none;
        }
        #zoomOutBtn:hover {
            background-color: rgba(255,255,255,0.2);
        }
        #wallSelector {
            position: absolute;
            left: 20px;
            top: 90%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        #wallSelector button {
            padding: 8px 12px;
            border: 1px solid white;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            border-radius: 5px;
            cursor: pointer;
            font-weight: normal;
            box-shadow: none;
            transition: background-color 0.3s ease;
        }
        #wallSelector button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="Tag3DScene"></div>
    <div id="info">Museu Virtual de Moda • Use o mouse para navegar</div>
    <button id="zoomOutBtn">Voltar à vista geral</button>
    <div id="wallSelector">
        <button onclick="goToWall('blue')">Serenidade</button>
        <button onclick="goToWall('red')">Fúria Criativa</button>
        <button onclick="goToWall('green')">Ressurgir</button>
    </div>

    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js';

        
        // Obter o avatar selecionado da URL
        const urlParams = new URLSearchParams(window.location.search);
        const selectedAvatar = urlParams.get('avatar') || '1'; // Default para avatar 1 se não especificado

        const sceneElements = {
            sceneGraph: null,
            camera: null,
            renderer: null,
            controls: null,
            originalCameraPosition: null,
            originalControlsTarget: null
        };
    
        const helper = {
            initEmptyScene: function (sceneElements) {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                sceneElements.sceneGraph = scene;

                const width = window.innerWidth;
                const height = window.innerHeight;
                const camera = new THREE.PerspectiveCamera(80, width / height, 1, 100);
                sceneElements.camera = camera;
                camera.position.set(5, 10, 30);
                
                sceneElements.originalCameraPosition = camera.position.clone();
                sceneElements.originalControlsTarget = new THREE.Vector3(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                document.querySelector("#Tag3DScene").appendChild(renderer.domElement);
                sceneElements.renderer = renderer;

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.1;
                controls.minDistance = 5;
                controls.maxDistance = 200;
                controls.maxPolarAngle = Math.PI * 0.9;
                controls.screenSpacePanning = true;
                sceneElements.controls = controls;

                // ILUMINAÇÃO FIXA E ESTÁVEL
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
                scene.add(ambientLight);

                
                // Luz principal vindo de cima e à frente
                const mainLightLeft = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightLeft.position.set(-8, 15, 10);
                mainLightLeft.castShadow = true;
                mainLightLeft.shadow.mapSize.width = 2048;
                mainLightLeft.shadow.mapSize.height = 2048;
                scene.add(mainLightLeft);

                // Luz secundária vindo de cima e à frente-direita (simétrica)
                const mainLightRight = new THREE.DirectionalLight(0xfff7e6, 1.2);
                mainLightRight.position.set(8, 15, 10); // Posição mais à direita
                mainLightRight.castShadow = true;
                mainLightRight.shadow.mapSize.width = 2048;
                mainLightRight.shadow.mapSize.height = 2048;
                scene.add(mainLightRight);

                // Luz de preenchimento central mais forte
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
                fillLight.position.set(0, 12, 5); // Posição mais central
                scene.add(fillLight);

                // Luzes fixas para os quadros (aumentei a intensidade para 40)
                const frameLight1 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight1.position.set(-15, 12, -35);
                frameLight1.target.position.set(-15, 7.5, -37.5);
                scene.add(frameLight1);
                scene.add(frameLight1.target);

                const frameLight2 = new THREE.SpotLight(0xfff7e6, 40, 20, Math.PI/6, 0.7);
                frameLight2.position.set(15, 12, -35);
                frameLight2.target.position.set(15, 7.5, -37.5);
                scene.add(frameLight2);
                scene.add(frameLight2.target);

                // Luz ambiente adicional para o centro da sala (aumentei o alcance)
                const centerLight = new THREE.PointLight(0xfff7e6, 20, 20);
                centerLight.position.set(0, 10, 0);
                scene.add(centerLight);
            },

            render: function (sceneElements) {
                TWEEN.update();
                sceneElements.controls.update();
                sceneElements.renderer.render(sceneElements.sceneGraph, sceneElements.camera);
                requestAnimationFrame(() => helper.render(sceneElements));
            },

            setupDoubleClickZoom: function(sceneElements) {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                function onDoubleClick(event) {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, sceneElements.camera);
                    
                    const intersects = raycaster.intersectObjects(
                        sceneElements.sceneGraph.children.filter(obj => 
                            obj.userData && obj.userData.isDisplay
                        )
                    );
                    
                    if (intersects.length > 0) {
                        const mockup = intersects[0].object;
                        const frameWidth = 6;
                        
                        const zoomDistance = frameWidth * 1.5;
                        
                        const direction = new THREE.Vector3()
                            .subVectors(mockup.position, sceneElements.camera.position)
                            .normalize();
                        
                        const zoomPosition = new THREE.Vector3()
                            .copy(mockup.position)
                            .addScaledVector(direction, -zoomDistance);
                        
                        zoomPosition.y = mockup.position.y;
                        
                        const targetRotation = new THREE.Quaternion()
                            .setFromUnitVectors(
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3().copy(direction).negate()
                            );
                        
                        new TWEEN.Tween(sceneElements.camera.position)
                            .to(zoomPosition, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                        
                        new TWEEN.Tween(sceneElements.controls.target)
                            .to(mockup.position, 1000)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                        
                        new TWEEN.Tween({
                            x: sceneElements.camera.quaternion.x,
                            y: sceneElements.camera.quaternion.y,
                            z: sceneElements.camera.quaternion.z,
                            w: sceneElements.camera.quaternion.w
                        })
                        .to({
                            x: targetRotation.x,
                            y: targetRotation.y,
                            z: targetRotation.z,
                            w: targetRotation.w
                        }, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .onUpdate(function() {
                            sceneElements.camera.quaternion.set(
                                this.x, this.y, this.z, this.w
                            );
                        })
                        .start();
                        
                        document.getElementById('zoomOutBtn').style.display = 'block';
                    }
                }
                
                window.addEventListener('dblclick', onDoubleClick);
                
                document.getElementById('zoomOutBtn').addEventListener('click', function() {
                    new TWEEN.Tween(sceneElements.camera.position)
                        .to(sceneElements.originalCameraPosition, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();
                    
                    new TWEEN.Tween(sceneElements.controls.target)
                        .to(sceneElements.originalControlsTarget, 1000)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .start();
                    
                    const originalRotation = new THREE.Quaternion()
                        .setFromEuler(sceneElements.camera.rotation);
                    
                    new TWEEN.Tween({
                        x: sceneElements.camera.quaternion.x,
                        y: sceneElements.camera.quaternion.y,
                        z: sceneElements.camera.quaternion.z,
                        w: sceneElements.camera.quaternion.w
                    })
                    .to({
                        x: originalRotation.x,
                        y: originalRotation.y,
                        z: originalRotation.z,
                        w: originalRotation.w
                    }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .onUpdate(function() {
                        sceneElements.camera.quaternion.set(
                            this.x, this.y, this.z, this.w
                        );
                    })
                    .start();
                    
                    setTimeout(() => {
                        document.getElementById('zoomOutBtn').style.display = 'none';
                    }, 1000);
                });
            }
        };

        const scene = {
            load3DObjects: function (sceneGraph) {
                const textureLoader = new THREE.TextureLoader();
                
                const wallTexture = textureLoader.load('stone-shells-fossil-texture.jpg');
                wallTexture.wrapS = THREE.RepeatWrapping;
                wallTexture.wrapT = THREE.RepeatWrapping;
                wallTexture.repeat.set(4, 4);

                const wallMaterial = new THREE.MeshStandardMaterial({
                    map: wallTexture,
                    roughness: 0.0,
                    metalness: 0.0
                });

                const floorMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color ("#f5e1ce"),
                    roughness: 0.2,
                    metalness: 0.1,
                    transparent: true,                    
                    thickness: 0.5
                });

                const roomWidth = 50;
                const roomDepth = 80;
                const wallHeight = 15;
                const wallThickness = 0.5;

                // Chão
                const floor = new THREE.Mesh(
                    new THREE.PlaneGeometry(roomWidth, roomDepth),
                    floorMaterial
                );
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                sceneGraph.add(floor);

                // Paredes
                const walls = new THREE.Group();
                
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(roomWidth, wallHeight, wallThickness),
                    wallMaterial
                );
                backWall.position.set(0, wallHeight/2, -roomDepth/2);
                walls.add(backWall);
                
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, roomDepth),
                    wallMaterial
                );
                leftWall.position.set(-roomWidth/2, wallHeight/2, 0);
                walls.add(leftWall);
                
                const rightWall = leftWall.clone();
                rightWall.position.set(roomWidth/2, wallHeight/2, 0);
                walls.add(rightWall);
                
                sceneGraph.add(walls);

               // PAREDE FRONTAL COM ABERTURA PARA PORTA
                const doorWidth = 6.5;
                const doorHeight = 9.0;
                const wallSideWidth = (roomWidth - doorWidth) / 2;

               // Substitua a parte da parede frontal por este código:
                const frontWallTexture = textureLoader.load('teto.png', (texture) => {
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    
                    // Ajuste para melhor qualidade da textura
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.encoding = THREE.sRGBEncoding;
                    
                    // Criar a parede frontal como um único plano
                    const frontWallMaterial = new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide,
                        roughness: 0.7,
                        metalness: 0.1,
                        transparent: true,
                        alphaTest: 0.5
                    });

                    const frontWall = new THREE.Mesh(
                        new THREE.PlaneGeometry(roomWidth, wallHeight),
                        frontWallMaterial
                    );
                    
                    // Posicionar a parede
                    frontWall.position.set(0, wallHeight/2, roomDepth/2);
                    frontWall.rotation.y = Math.PI; // Girar para ficar virada para dentro
                    
                    // Adicionar a porta por cima (usando a mesma abordagem anterior)
                    const doorMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color ("#f5e1ce"),
                        roughness: 0.4,
                        metalness: 0.2
                    });

                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(doorWidth, doorHeight, wallThickness/2),
                        doorMaterial
                    );
                    door.position.set(0, doorHeight/2, roomDepth/2 + 0.1);
                    door.castShadow = true;
                    
                    // Adicionar ambos à cena
                    sceneGraph.add(frontWall);
                    sceneGraph.add(door);
                    
                    // Ajustar coordenadas UV para cortar a textura corretamente
                    frontWall.geometry.computeBoundingBox();
                    const boundingBox = frontWall.geometry.boundingBox;
                    const uvAttribute = frontWall.geometry.attributes.uv;
                    
                    for (let i = 0; i < uvAttribute.count; i++) {
                        const u = uvAttribute.getX(i);
                        const v = uvAttribute.getY(i);
                        
                        // Ajustar as coordenadas UV para esticar a textura corretamente
                        uvAttribute.setXY(i, u, v * 0.8); // Ajuste o 0.8 conforme necessário
                    }
                    uvAttribute.needsUpdate = true;
                });

                // BANCO CENTRAL MODERNO
                const createModernBench = () => {
                    const benchGroup = new THREE.Group();
                    
                    const woodMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color("#e8d5b5"),
                        roughness: 0.5,
                        metalness: 0.2
                    });
                    
                    const metalMaterial = new THREE.MeshStandardMaterial({
                        color: 0xFFD700,
                        metalness: 0.8,
                        roughness: 0.3
                    });

                    const length = 30;
                    const width = 1;
                    const height = 0.7;
                    const legHeight = 1.5;

                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(length, height, width),
                        woodMaterial
                    );
                    seat.position.y = legHeight + height/2;
                    seat.castShadow = true;
                    benchGroup.add(seat);

                    const legGeometry = new THREE.BoxGeometry(0.1, legHeight, 0.1);
                    const legPositions = [
                        { x: -length/2 + 0.5, z: -width/2 + 0.1 },
                        { x: length/2 - 0.5, z: -width/2 + 0.1 },
                        { x: -length/2 + 0.5, z: width/2 - 0.1 },
                        { x: length/2 - 0.5, z: width/2 - 0.1 }
                    ];
                    
                    legPositions.forEach(pos => {
                        const leg = new THREE.Mesh(legGeometry, metalMaterial);
                        leg.position.set(pos.x, legHeight/2, pos.z);
                        benchGroup.add(leg);
                    });

                    const sideBar = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, length - 1, 8),
                        metalMaterial
                    );
                    sideBar.position.set(0, legHeight + 0.02, -width/2 + 0.15);
                    sideBar.rotation.z = Math.PI/2;
                    benchGroup.add(sideBar);

                    benchGroup.position.set(0, 0, 0);
                    benchGroup.rotation.y = Math.PI/2;

                    return benchGroup;
                };

                const modernBench = createModernBench();
                sceneGraph.add(modernBench);

                // adicionamos o avatar
                this.addAvatar(sceneGraph, selectedAvatar);
            
                // TETO PLANO COM IMAGEM
                this.addFlatCeilingWithLights(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Quadros para mockups
                this.addPlaceholderFrames(sceneGraph, roomWidth, roomDepth, wallHeight);

                // Colunas do museu
                this.addMuseumColumns(sceneGraph, roomWidth, roomDepth, wallHeight);
            },

            // Função para adicionar o avatar ao museu
            addAvatar: function(sceneGraph, avatarType) {
                const avatarGroup = new THREE.Group();
                
                // Cores baseadas no tipo de avatar (igual ao index.html)
                let color;
                switch(avatarType) {
                    case '1': color = 0x3498db; break; // Azul - Explorador
                    case '2': color = 0xe74c3c; break; // Vermelho - Estilista
                    case '3': color = 0x2ecc71; break; // Verde - Historiador
                    default: color = 0x3498db;  // Default azul
                }

                // Cabeça
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 32, 32),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xF5DEB3,
                        roughness: 0.3,
                        metalness: 0.1
                    })
                );
                head.position.y = 1.5;
                avatarGroup.add(head);
                
                // Corpo
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1.5, 0.5),
                    new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.4,
                        metalness: 0.2
                    })
                );
                body.position.y = 0.75;
                avatarGroup.add(body);
                
                // Braços
                const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const leftArm = new THREE.Mesh(
                    armGeo, 
                    new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.4,
                        metalness: 0.2
                    })
                );
                leftArm.position.set(-0.6, 1, 0);
                avatarGroup.add(leftArm);
                
                const rightArm = leftArm.clone();
                rightArm.position.set(0.6, 1, 0);
                avatarGroup.add(rightArm);
                
                // Pernas
                const legGeo = new THREE.BoxGeometry(0.3, 0.8, 0.3);
                const leftLeg = new THREE.Mesh(
                    legGeo, 
                    new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.5
                    })
                );
                leftLeg.position.set(-0.25, -0.4, 0);
                avatarGroup.add(leftLeg);
                
                const rightLeg = leftLeg.clone();
                rightLeg.position.set(0.25, -0.4, 0);
                avatarGroup.add(rightLeg);
                
                // Posicionar o avatar no museu (perto da entrada)
                avatarGroup.position.set(0, 1.5, 20);
                avatarGroup.scale.set(2.5,2.5,2.5); // Um pouco maior
                
                sceneGraph.add(avatarGroup);
                sceneElements.avatar = avatarGroup; // Guardamos referência
            },

            // Função para animar o avatar (opcional)
            animateAvatar: function() {
                if (!sceneElements.avatar) return;
                
                let movingForward = true;
                const speed = 0.05;
                const maxZ = 15;
                const minZ = 25;
                
                function move() {
                    requestAnimationFrame(move);
                    
                    if (movingForward) {
                        sceneElements.avatar.position.z -= speed;
                        if (sceneElements.avatar.position.z <= maxZ) {
                            movingForward = false;
                        }
                    } else {
                        sceneElements.avatar.position.z += speed;
                        if (sceneElements.avatar.position.z >= minZ) {
                            movingForward = true;
                        }
                    }
                    
                    // Pequena animação de caminhada
                    sceneElements.avatar.rotation.y += 0.01;
                }
                
                move();
            }, 

            addPlaceholderFrames: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const goldFrameMaterial = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    metalness: 0.9,
                    roughness: 0.3,
                    emissive: 0x222200,
                    emissiveIntensity: 0.2
                });

                const frameWidth = 6;
                const frameHeight = 10;
                const frameDepth = 0.3;
                const frameOffset = 0.2;

                const mockupImages = [
                    'mockup1.png',
                ];

                const framePositions = [
                    { x: -20, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0 },
                    { x: -10, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0 },
                    { x: 0, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0 },
                    { x: 10, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0 },
                    { x: 20, y: wallHeight/2, z: -roomDepth/2 + frameOffset, rotY: 0 },
                    
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -20, rotY: Math.PI/2 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: -7, rotY: Math.PI/2 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 7, rotY: Math.PI/2 },
                    { x: -roomWidth/2 + frameOffset, y: wallHeight/2, z: 20, rotY: Math.PI/2 },
                    
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -20, rotY: -Math.PI/2 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: -7, rotY: -Math.PI/2 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 7, rotY: -Math.PI/2 },
                    { x: roomWidth/2 - frameOffset, y: wallHeight/2, z: 20, rotY: -Math.PI/2 }
                ];

                const textureLoader = new THREE.TextureLoader();
                
                framePositions.forEach((pos, index) => {
                    const frameGroup = new THREE.Group();
                    
                    const front = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, frameHeight, frameDepth/3),
                        goldFrameMaterial
                    );
                    front.position.z = frameDepth/3;
                    frameGroup.add(front);
                    
                    const sideDepth = frameDepth * 0.7;
                    const left = new THREE.Mesh(
                        new THREE.BoxGeometry(frameDepth/2, frameHeight, sideDepth),
                        goldFrameMaterial
                    );
                    left.position.set(-frameWidth/2 + frameDepth/4, 0, sideDepth/2);
                    frameGroup.add(left);
                    
                    const right = left.clone();
                    right.position.set(frameWidth/2 - frameDepth/4, 0, sideDepth/2);
                    frameGroup.add(right);
                    
                    const top = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth + frameDepth/2, frameDepth/2, sideDepth),
                        goldFrameMaterial
                    );
                    top.position.set(0, frameHeight/2 - frameDepth/4, sideDepth/2);
                    frameGroup.add(top);
                    
                    const bottom = top.clone();
                    bottom.position.set(0, -frameHeight/2 + frameDepth/4, sideDepth/2);
                    frameGroup.add(bottom);
                    
                    frameGroup.position.set(pos.x, pos.y, pos.z);
                    frameGroup.rotation.y = pos.rotY;
                    sceneGraph.add(frameGroup);

                    const imageIndex = index % mockupImages.length;
                    const imageUrl = mockupImages[imageIndex];
                    
                    textureLoader.load(imageUrl, (texture) => {
                        texture.encoding = THREE.sRGBEncoding;
                        
                        const mockupMaterial = new THREE.MeshStandardMaterial({
                            map: texture,
                            roughness: 0.5,
                            metalness: 0.0,
                            side: THREE.DoubleSide,
                            transparent: true,
                            alphaTest: 0.5
                        });

                        const mockup = new THREE.Mesh(
                            new THREE.PlaneGeometry(frameWidth*0.9, frameHeight*0.9),
                            mockupMaterial
                        );
                        mockup.position.copy(frameGroup.position);
                        mockup.position.z += pos.rotY === 0 ? frameDepth/2 + 0.02 : 
                                         (pos.rotY === Math.PI/2 ? -frameDepth/2 - 0.02 : frameDepth/2 + 0.02);
                        mockup.rotation.y = pos.rotY;
                        mockup.userData.isDisplay = true;
                        sceneGraph.add(mockup);
                    }, undefined, (error) => {
                        console.error('Erro ao carregar textura:', error);
                    });
                });
            },

            addMuseumColumns: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const columnMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color("#e8d5b5"),
                    roughness: 0.5,
                    metalness: 0.2
                });
                
                const columnGeometry = new THREE.CylinderGeometry(0.8, 0.8, wallHeight, 8);
                
                const columns = [
                    { x: -roomWidth/3, z: -roomDepth/3 },
                    { x: roomWidth/3, z: -roomDepth/3 },
                    { x: -roomWidth/3, z: roomDepth/3 },
                    { x: roomWidth/3, z: roomDepth/3 }
                ];
                
                columns.forEach(pos => {
                    const column = new THREE.Mesh(columnGeometry, columnMaterial);
                    column.position.set(pos.x, wallHeight/2, pos.z);
                    sceneGraph.add(column);
                });
            },

            addFlatCeilingWithLights: function(sceneGraph, roomWidth, roomDepth, wallHeight) {
                const textureLoader = new THREE.TextureLoader();
                
                const ceilingTexture = textureLoader.load('teto.png', undefined, undefined, 
                    (error) => console.error('Erro ao carregar textura:', error));
                
                const ceilingMaterial = new THREE.MeshStandardMaterial({
                    map: ceilingTexture,
                    side: THREE.DoubleSide,
                    roughness: 0.7,
                    metalness: 0.1,
                    color: new THREE.Color(0.7, 0.7, 0.7)
                });

                const ceilingGeometry = new THREE.PlaneGeometry(roomWidth, roomDepth);
                
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.rotation.x = Math.PI/2;
                ceiling.position.y = wallHeight;
                ceiling.receiveShadow = true;
                
                sceneGraph.add(ceiling);
            }

        };

            function goToWall(color) {
            let camPosition, camTarget, avatarPosition, avatarRotationY;
            switch(color) {
                case 'blue':
                    camPosition = new THREE.Vector3(0, 7, -5);
                    camTarget = new THREE.Vector3(0, 10, -40);
                    avatarPosition = new THREE.Vector3(0, 1.5, -35);
                    avatarRotationY = 0;
                    break;
                case 'red':
                    camPosition = new THREE.Vector3(20, 7, 0);
                    camTarget = new THREE.Vector3(0, 7, 0);
                    avatarPosition = new THREE.Vector3(-22, 0, 0);
                    avatarRotationY = Math.PI / 2;
                    break;
                case 'green':
                    camPosition = new THREE.Vector3(-10, 7, 0);
                    camTarget = new THREE.Vector3(70, 7, 0);
                    avatarPosition = new THREE.Vector3(22, 0, 0);
                    avatarRotationY = -Math.PI / 2;
                    break;
            }

            new TWEEN.Tween(sceneElements.camera.position)
                .to({ x: camPosition.x, y: camPosition.y, z: camPosition.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sceneElements.controls.target)
                .to({ x: camTarget.x, y: camTarget.y, z: camTarget.z }, 1000)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            if (sceneElements.avatar) {
                new TWEEN.Tween(sceneElements.avatar.position)
                    .to({ x: avatarPosition.x, y: 0, z: avatarPosition.z }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                new TWEEN.Tween(sceneElements.avatar.rotation)
                    .to({ y: avatarRotationY }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
            }

            document.getElementById('zoomOutBtn').style.display = 'block';
        }
        window.goToWall = goToWall;

        // Controlos com teclado
        window.addEventListener("keydown", (event) => {
            if (!sceneElements.avatar) return;

            const speed = 0.5;
            const avatar = sceneElements.avatar;

            let moved = false;
            switch (event.key) {
                case "ArrowUp":
                    avatar.position.z -= speed;
                    moved = true;
                    break;
                case "ArrowDown":
                    avatar.position.z += speed;
                    moved = true;
                    break;
                case "ArrowLeft":
                    avatar.position.x -= speed;
                    avatar.rotation.y = Math.PI / 2;
                    moved = true;
                    break;
                case "ArrowRight":
                    avatar.position.x += speed;
                    avatar.rotation.y = -Math.PI / 2;
                    moved = true;
                    break;
            }

            if (moved) animateWalkCycle();
        });

        function animateWalkCycle() {
            const avatar = sceneElements.avatar;
            if (!avatar) return;

            const leftArm = avatar.children.find(c => c.position.x < 0 && c.geometry.parameters.height === 0.8);
            const rightArm = avatar.children.find(c => c.position.x > 0 && c.geometry.parameters.height === 0.8);
            const leftLeg = avatar.children.find(c => c.position.x < 0 && c.geometry.parameters.height === 0.8 && c.position.y < 0);
            const rightLeg = avatar.children.find(c => c.position.x > 0 && c.geometry.parameters.height === 0.8 && c.position.y < 0);

            [leftArm, rightArm, leftLeg, rightLeg].forEach(limb => {
                if (!limb) return;
                const initialRot = { x: limb.rotation.x };
                new TWEEN.Tween(initialRot)
                    .to({ x: 0.5 }, 100)
                    .yoyo(true)
                    .repeat(1)
                    .onUpdate(() => { limb.rotation.x = initialRot.x; })
                    .start();
            });
        }

        function init() {
            helper.initEmptyScene(sceneElements);
            scene.load3DObjects(sceneElements.sceneGraph);
            helper.setupDoubleClickZoom(sceneElements);
            helper.render(sceneElements);
        }

        window.addEventListener("resize", () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            sceneElements.camera.aspect = width / height;
            sceneElements.camera.updateProjectionMatrix();
            sceneElements.renderer.setSize(width, height);
        });

        init();
    </script>
</body>
</html>